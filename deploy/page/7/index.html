
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    
    <title>openQ</title>
    <!-- <link href='http://fonts.googleapis.com/css?family=Abel' rel='stylesheet' type='text/css'> -->
    <link rel="stylesheet" href="http://openq.cn/static/css/style.css?v=93a21dd84893fe7b3512f972ded50a5c" type="text/css" />
    <link rel="stylesheet" href="http://openq.cn/static/css/pygments_style.css?v=f52807bdba7d67ebabc3ce287f67bf67" type="text/css" />
    <link rel="alternate" type="application/rss+xml" href="http://openq.cn/feed.xml" title="openQ" />
    <link rel="canonical" href=""/>
    <link rel="shortcut icon" href="http://openq.cn/static/favicon.ico?v=64341ece5c43f8fa3d9e2f4793a11590" />
</head>
<body>
<div id="header">
    <div id="nav_wrapper">
        <div id="nav">
            <div class="inner">
                <h1 id="title"><a href="http://openq.cn/">openQ</a></h1>
                <div id="description" class="seal">开放 包容 多走些路  本博客文章恢复中...</div>
                <ul class="right">
                    
                    <li><a href="http://openq.cn/about/">about</a></li>
                    <li class="dot">&bull;</li>
                    
                </ul>
            </div>
        </div>
    </div>
    <div id="header_inner">
        <div id="social">
            <a href="http://twitter.com/hl13571" target="_blank" title="Follow Me @ Twitter"><img src="http://openq.cn/static/image/ic16_twitter.png?v=ad066c7795c123199e5818835ba0b8cf"></a>
            <a href="http://github.com/hl85" target="_blank" title="Fork Me @ Github"><img src="http://openq.cn/static/image/ic16_github.png?v=2fd2b5b5fb5b76306ff8b5896b4884a1"></a>
            <a href="http://openq.cn/feed.xml" target="_blank" title="Subscribe My Blog"><img src="http://openq.cn/static/image/ic16_rss.png?v=c230e9b2bfaab8f8142b235c22430bc2"></a>
        </div>
        <div class="sep"></div>
    </div>
</div>
<div id="content">
    
<ul id="article_list">
    
    <li class="list_item">
        <div class="article">
            <div class="inner">
                <h2 class="article_title title"><a href="http://openq.cn/use-the-data-in-the-local-application-of-the-uri-scheme/">本地应用里使用Data URI scheme</a></h2>
                <div class="article_meta">
                    <span>on</span>
                    2012-03-26
                </div>

                <div class="text">
                    <p>之前跟钟小声一起探讨过关于Data URI scheme 数据传递的问题，就是从objective-c中调用uiwebview或safari显示刚刚处理的图片。UIWebView里边采用这种Data URI scheme很合适，但是oc调用safari就比较麻烦了（url长度有限制），解决方案是自己起一个http的服务，然后传递http://localhost:[port]/[yourpage.html] ，([port]替换成相应的端口，[yourpage.html]替换成相应的页面)，这个时候你怎么显示图片都很容易了。这里有一个问题http service库很庞大，实际上你不用实现完整的http service，只要写一个简单的socket监听就ok了，满足需求就好（当然这超出了本文讨论的范围，可以稍后单独发帖讨论）。  </p>

<p>另外，今天刚好看到有人（facebook）在iPhone客户端里，使用了用html写的loading页和error页（貌似菊花动画是用css3实现的，稍后再确定）<br/>
Data URI scheme的html嵌入式，形如：  </p>
<div class="highlight"><pre><span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==&quot;</span><span class="nt">/&gt;</span>
</pre></div>

<p>如此，在html中嵌入，实际上是将图片进行base64处理，直接写到网页里，从而减少一次网络请求加快页面显示。当然在app中使用:  </p>
<div class="highlight"><pre><span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">&quot;data:image/png;base64,%@&quot;</span><span class="nt">/&gt;</span>
</pre></div>

<p>这样的办法显示loading页和error页也是很方便的（facebook是这么干的）  </p>

<p>还有一种是直接通过url传递，你可以将以下代码贴到地址栏，回车看效果（一个小红点儿;）。  </p>

<pre><code>data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==</code></pre>

<p>这样可以实现跨域传输数据（如objcetive-c向safari），但是，无奈你也得注意url的长度限制。  </p>

<p>简单科普一下Data URI scheme:  </p>

<p>Data URI scheme是在RFC2397中定义的，目的是将一些小的数据，直接嵌入到网页中，从而不用再从外部文件载入。比如上面那串字符，其实是一张小图片，将这些字符复制黏贴到火狐的地址栏中并转到，就能看到它了，一张1X36的白灰png图片。在上面的Data URI中，data表示取得数据的协定名称，&quot;image/png&quot;是数据类型名称，&quot;base64&quot;是数据的编码方法，逗号后面就是这个image/png文件base64编码后的数据。  </p>

<p>目前，Data URI scheme支持的类型有：  </p>

<pre><code>data:,文本数据  
data:text/plain,文本数据  
data:text/html,HTML代码  
data:text/html;base64,base64编码的HTML代码  
data:text/css,CSS代码  
data:text/css;base64,base64编码的CSS代码  
data:text/javascript,Javascript代码  
data:text/javascript;base64,base64编码的Javascript代码  
data:image/gif;base64,base64编码的gif图片数据  
data:image/png;base64,base64编码的png图片数据  
data:image/jpeg;base64,base64编码的jpeg图片数据  
data:image/x-icon;base64,base64编码的icon图片数据</code></pre>

<p>base64简单地说，它把一些 8-bit 数据翻译成标准 ASCII 字符，网上有很多免费的base64编码和解码的工具，在PHP中可以用函数base64_encode() 进行编码，如:  </p>
<div class="highlight"><pre><span class="x">echo base64_encode(file_get_contents(‘wg.png’));</span>
</pre></div>

<p>目前，IE8、Firfox、Chrome、Opera浏览器都支持这种小文件嵌入.</p>

                </div>
                <div class="article_meta">
                    <span>tagged:</span>
                    
                    <a class="tag" href="http://openq.cn/tag/front-end/">front end</a>
                    
                </div>
            </div>
        </div>
        <div class="sep"></div>
    </li>
    
    <li class="list_item">
        <div class="article">
            <div class="inner">
                <h2 class="article_title title"><a href="http://openq.cn/facebook-phonegap-mosync-cross-platform-architecture-urine-point-js-framework/">Facebook、PhoneGap、MoSync跨平台架构尿点小窥（js框架角度）</a></h2>
                <div class="article_meta">
                    <span>on</span>
                    2012-03-22
                </div>

                <div class="text">
                    <p>今晚研究了一下从Facebook iPhone app中搞到的bridge.js，趁热对Facebook、PhoneGap、MoSync的js框架进行一个简要的对比。首先，个人认为程序架构和设计模式的关键就是：1、需求或领域（Domain）的粒度。2、对变化点的封装–标题中的‘尿点’就是指的这亮点了。另外，之所以没有在 Appcelerator 上花时间，是因为一来这玩意不开源，二来我还没有看到除了ide外其他可借鉴的东西。  </p>

<p>下面是三个平台的Js框架代码下载及对比（除了phoneGap其他两个的代码都是抠出来的，不仔细找很难找到）：  </p>

<p>1、Facebook –&gt; bridge.js 下载 (线上app包里有一个bridgekit.bundle的资源包)  </p>

<p>说明：私有框架（只针对facebook自己产品），跨平台特点：目前产品采用的是Html5页面 + 原生页面的模式，部分页面或界面采用了Html5，页面加速度优化的相当成功（哥们就是想学习它的页面加速度解决方案才各种抓包、破解的），原生导航机制，各种互调。  </p>

<p>js-&gt;尿点：  </p>

<p>1）短短200来行代码，实现了原生类和js类的转换（Mapping）。这个实现方案的典型特点是灵活，原则上来说js脚本可以掉用所有的原生代码（安全漏洞有木有！！！本人就准备动过这个文件对facebook的app进行抓包，https加密哥们绕开你啦，哈哈！）  </p>

<p>2）看这段代码（第100行）  </p>

<p>var url = ‘http://’+(location.host||’localhost‘)+’/<strong>bridge</strong>/’+<strong>token+’/&#39;+</strong>generateToken();  </p>

<p>跟phoneGap 不同它是通过起了一个http服务实现的html5和原生代码的通信管道（很大概率上是这样，等我抓到的location.host变量的值了之后才能最终确定。也就是还有下文，敬请期待，哈哈！  </p>

<p>2、PhoneGap –&gt;  phonegap-1.3.0.js下载  </p>

<p>说明：公共框架（开源编程框架），跨平台特点：主要应用一般都采用Html5 App + 原生壳模式，目前社区热度最高的开源跨平台解决方案（还有一个解决方案，），通过开发插件实现对原生调用的扩充，默认不支持原生导航，互调一般也是限于重力加速度、定位、照相等原生设备级的。  </p>

<p>js-&gt;尿点：  </p>

<p>1)代码量非常大（4000多行有木有！！）实现了约定了并且在配置文件中开启的原生接口和html5的Mapping（看这么拗口就知道——相当安全），实现了设备能力级的互调。插件式架构，可以通过编写插件来扩展互调的范围，比如你自己写一个支持回调的原生输入框，遵照其plugin规范就可以被js调用到了。这个框架代码很少，架构清晰，SDK非常的产品化。当然也就没有facebook的灵活了。还有，也没有Appcelerator IDE这样牛x的调试工具。  </p>

<p>2）看这段代码：  </p>

<p>PhoneGap.createGapBridge = function() {<br/>
gapBridge = document.createElement(“iframe”);<br/>
gapBridge.setAttribute(“style”, “display:none;”);<br/>
gapBridge.setAttribute(“height”,”0px”);<br/>
gapBridge.setAttribute(“width”,”0px”);<br/>
gapBridge.setAttribute(“frameborder”,”0″);<br/>
document.documentElement.appendChild(gapBridge);<br/>
return gapBridge;<br/>
}  </p>

<p>它是通过给iframe设置一个url出发webview的导航事件实现内外互调的(这里说的是针对iOS平台的机制)，这个机制很轻量也很灵活。这个之后还有一个消息队列机制，这个我会专门写文章详细说明这个东东，有点意思，但我还要评估这个东西是不是画蛇添足了（包括使用iframe)。  </p>

<p>3、MoSync –&gt; mosync-bridge.js下载（深入认识MoSync也是因为新版Facebook中用到的bridge.js）  </p>

<p>说明：公共框架（开源、提供开发Ide——很类似Appcelerator，但开发体验差很多），跨平台特点：Mosync支持平台相当的多，毕竟人家使用C++开发的底层架构，标榜的是效率很高，但是通过对其工具、及学习成本等分析粗浅认为，即使你很迷恋单独的ide，想用这玩意做一般产品还不如用Appcelerator（跑个题Appcelerator的Titanium IDE可以在iPhone模拟器上调试js，够酷吧！）。当然，你要研究代码或底层架构，这个再好不过了，一来框架封装的轮子够多，二来开源，github有下（100+M的代码）。  </p>

<p>js-&gt;尿点：  </p>

<p>1）框架比较乱，有界面也有机制的东西，不是很干净，但代码量同样很少，架构封装点不是很明确，因为分析的是它二点几的版本的js框架所以就重点说说互调机制。实际上，看到它的文档里，有大量的内容标注了和phoneGap兼容，或许3.0以后这个东东会废弃掉以前的c++代码（100多兆啊！！），个人判断有不同观点可以留言讨论。  </p>

<p>2）还是上代码：<br/>
<code>javascript  
if (mosync.isAndroid)  
{  
prompt(data, “”);  
}  
else if (mosync.isIOS)  
{  
rawMessageQueue.push(data);  
window.location = “mosync://DataAvailable”;  
}  
else if (mosync.isWindowsPhone)  
{  
window.external.notify(data);  
}  
</code>  </p>

<p>一家活三个平台的机制都暴露了，研究跨平台机制的同学看到这个爽了，哈哈！！！和phoneGap的机制如初一折，当然是谁的创意以后有精力在调研，基本就这些了，过两天再分析一下iOS、Android、Phone 7不同平台Html5互调的尿点。</p>

                </div>
                <div class="article_meta">
                    <span>tagged:</span>
                    
                    <a class="tag" href="http://openq.cn/tag/hybrid/">hybrid</a>
                    
                </div>
            </div>
        </div>
        <div class="sep"></div>
    </li>
    
    <li class="list_item">
        <div class="article">
            <div class="inner">
                <h2 class="article_title title"><a href="http://openq.cn/html5-mobile-development-practices/">HTML5的移动开发实践</a></h2>
                <div class="article_meta">
                    <span>on</span>
                    2012-03-10
                </div>

                <div class="text">
                    <p>如果你阅读稍微涉及前端科技的博客，那么你肯定每周都有可能看到关于HTML5的报道。虽然，这套新web标准没有强大到给你制造某个先进的家用电器，但是它的新特性的确可以帮你创建强大的应用程序，仅仅是使用html,css和javascript（当然，如果后端使用rails或者node.js的话，火力会更猛）。这篇文章主旨就是介绍关键概念及HTML5的牛逼特性，还有一些更牛逼的设置（当然是移动相关的了，牛皮吹的够大）。</p><p></p><h3>浏览器兼容性</h3><p>开发一个web应用最大的痛苦莫过于确保您的应用程序是与目前使用的各种浏览器兼容。&nbsp;幸运的是，在移动世界中这不是一个大问题（观点很新颖吧，我们继续）。&nbsp;因为比起换电脑来人们往往更频繁的更换新手机，因为用户群体相对年轻，旧的智能手机很快就被市场淘汰。另外，iPhone、android内核都是webkit，所以这也给兼容性创造了条件。当然，处于市场考虑，你要支持更多的设备的话，还是要使用真机测试，而不是模拟器。不过，随着标准的完善和设备性能的提升，适配的复杂度将会逐步降低的。</p><h3>Viewport</h3><p>当你用移动设备浏览一个互联网网页，这个网页在你的浏览器里是被缩放了的，这是浏览器为了让你看到网站全貌做的简单自动适配（缩放）。当然，你想看具体内容也可以再放大。不过，如果你正在针对智能手机设计网页，那么viewport的定义将是非常有意义的（viewport meta tag）：</p><p>    <span style="font-family: Consolas , Monaco , monospace;font-size: 12.0px;line-height: 18.0px;white-space: pre;">&lt;meta name=&ldquo;viewport&rdquo; content = &ldquo;width=device-width”&gt;</span></p><p>    </p><p>        </p><p>&nbsp;这个宽度通常设置为设备屏幕宽度，因此，网页就没有必要再被浏览器默认缩小或放大了。你肯定就想禁用缩放行为，从而使用户不能无意中放大或缩小页面，使其产生扭曲变形。实现这个目的，你只需要将&nbsp;user-scalable 设置为no：</p>        <p>            &lt;meta name=&quot;viewport&rdquo; content = &ldquo;width=device-width , &nbsp;user-scalable=no&rdquo;&gt;            一些网站的移动版将页面宽度设置为320，这是为什么呢？因为这是iPhone的宽度。当然为了为更多用户带来更好的体验，你最好将宽度设为            device-width，320不靠谱。                            <a href="http://openq.cn/wp-content/uploads/2012/03/A4jFz.png"><img class="alignnone size-full wp-image-496" src="http://www.appfanr.com/wp-content/uploads/2012/03/A4jFz.png" alt="" width="610" height="436"></a>                        &nbsp;让你的网页使用正确的大小固然很nice，但是，下文将要提到的HTML5缓存（使用manifest）及存储特性，将使你能够构建全功能离线站点。在信号不是非常稳定的无线环境中，离线能力在用户体验中将承担相当的分量。            </p><h3>HTML5 Caching</h3>            <p>HTML5 Caching 允许用户在没有网络连接的情况下浏览之前浏览过得内容，当然也不光是在没信号的时候可以浏览这一个好处，使用缓存还可以减少很多的连接请求，降低数据传输量。</p>            <p>设置缓存，你可以通过在每个网页的html标签中设置manifest文件来实现：</p>            &lt;html manifest=&ldquo;/cache.manifest&rdquo;&gt;            这是个文本文件，内容以&nbsp;“CACHE MANIFEST”开始，下面列举需要缓存的文件：            CACHE MANIFEST/mystyle.css/scripts.js/logo.jpg            这样这些文件就可以被离线使用了，只是这么一长串文件列表有时候也会成为陷阱，下面我将试图整理相关的要点：            首先最重要的是，你的网站将默认缓存最新的文件，这意味着，即使你刚刚访问的文件已经改变了，你的浏览器还是显示的老页面，直到这个页面被刷新（或者通过javascript通知更新）。事实上，更严重的是大部分的web server都会告诉客户端浏览器使用缓存，这样同步问题就尤为凸显。当你开发网页的时候，一定要在服务器上设置不要缓存manifest,这样你才能看或调试到你刚刚更新的网页。            另一个大问题是，浏览器如何管理下载过程。如果浏览器监测到manifest更改了，它将重新下载页面上使用的所有文件。这个过程非常昂贵，而且如果其中的单个文件不能下载，浏览器会放弃更新和加载以前的缓存。这个时候浏览器不会抛出任何错误，但是您可以通过javascript抛出异常清单：            $(function() {  $(window.applicationCache).bind(&ldquo;error&rdquo;, function() {    alert(&ldquo;Cache: update failed&rdquo;);  });});            现在你的网站已经被缓存了，并且可以很好的工作了。那么，这样就可以launch了吗？恐怕不行。这种caching技术只能在缓存静态文件的需求下工作正常，但是如果你的网页是动态创建的，或者经常改变的（大多数网页都是这样），它就不能正常工作了。这是因为除非缓存更新了，否则你看到的还是老网页，而不是新内容页。解决办法也很简单，就是当有新内容（或改动）的时候，更新manifest文件。当然正如前文我们讨论的，如果你的网站经常更新，这么做的代价是非常昂贵的。那咋整捏？解决办法就是使用jQuery建立动态模版页面。            <h3>jQuery 模板</h3>            <p>最好的做法是通过JavaScript模板来填充内容。 使用这种方式，内容不是HTML页面的一部分，因而是不会记录到缓存的manifest里。&nbsp;对于这一点，你需要下载jQuery和jQuery的<a href="http://rrurl.cn/phZmw2">模板插件</a>，并添加到您的应用程序&nbsp;。</p>            <p>使用这些模板有三个步骤：</p>            <ol>                <li>定义模板。</li>                <li>定义集合。</li>                <li>告诉jQuery来填充模板的页面。</li>            </ol>            <h4>下面是一个简单的博客应用的一个例子。</h4>            <p>1.&nbsp;&nbsp;定义模板：</p>            <p>                </p><p>                    &lt;script id=&ldquo;post_template&rdquo; type=&ldquo;text/html”&gt;&lt;div&gt;&lt;h2&gt;${Name}&lt;/h2&gt;&lt;p&gt;${Body}&lt;/p&gt;&lt;/div&gt;&lt;/script&gt;                </p>            <p></p>            <p>2.&nbsp;定义数据集合（以下使用JSON）。</p>            <p>                </p><p>                    &lt;script&gt;var posts = [{ Name: &quot;First!&rdquo;, Body: &ldquo;This is pretty cool&rdquo; },{ Name: &ldquo;Another post&rdquo;, Body: &ldquo;This is pretty cool&rdquo; },{ Name: &ldquo;Yet another blog post&rdquo;, Body: &ldquo;This is pretty cool&rdquo; }];&lt;/script&gt;                </p>            <p></p>            <p>3.&nbsp;告诉jQuery使用模板填充页面。</p>            <p>                </p><p>                    &lt;script&gt;$( &ldquo;#post_template&rdquo; ).tmpl( posts ).appendTo( &ldquo;#blog_posts&rdquo; );&lt;/script&gt;&nbsp;…&nbsp;&lt;body&gt;&nbsp;&lt;div id=&ldquo;blog_posts&rdquo;&gt;&lt;/div&gt;&nbsp;&lt;/body&gt;                    虽然这个内容是通过JavaScript加载，但它不是动态的，它只是在页面上定义的。&nbsp;对于动态内容，我们需要使用服务器提供的JSON接口。&nbsp;假设我们的博客应用程序提供给了我们这样的JSON接口：                    http://www.yourhost.com/&hellip;/posts.json                    我们会告诉jQuery对以上网站发送一个JSON请求，然后用返回的数据来填充页面：                    &lt;script type=&ldquo;text/javascript&rdquo;&gt;$.getJSON(&lsquo;/posts.json&rsquo;, function(data) {$( &ldquo;#post_template&rdquo; ).tmpl( data ).appendTo( &ldquo;#blog_posts&rdquo; );});&lt;/script&gt;                    我们还需要修改模板，以便它可以处理JSON元素，post.body对应文章的内容，post.name对应文章的标题：                    &lt;script id=&ldquo;post_template&rdquo; type=&ldquo;text/html&rdquo;&gt;&lt;div&gt;  &lt;h2&gt;${post.name}&lt;/h2&gt;  &lt;p&gt;${post.body}&lt;/p&gt;&lt;/div&gt;&lt;/script&gt;                    现在，你的博客数据已经不是缓存在manifest的静态内容了，而是通过jQuery动态跟服务器获取的。然而，这样只有我们的手机有网络连接的时候，网页才能工作了。是不是感觉进了2步却退了3步？别着急，请相信我，我们马上就搞定一个HTML5 mobile app了。我们只需要实现最后一个HTML5接口，本地存储（Local Storage）。                    </p><h3>本地存储（Local Storage）</h3>                    <p>关于本地存储的细节，辉郎准备在单独的文章里详细介绍，这里尽量简化到初学者容易接受的程度。</p>                    <p>本地存储实际上是通过浏览器实现的key-value的存储。通过它，我们可以实现将文本存储到本地，并在稍后重新调用到。在这里，我们使用它来存储JSON，所以我们可以填充博客文章——即使我们没有连接到服务器。</p>                    <p>虽然我们可以手工编写，但是这里有一个很牛x的插件帮我们管理整个过程。&nbsp;jQuery的离线插件，可以在服务器不可用的时候使用本地存储的内容。收到新鲜的内容，它会将其存储存到本地（local storage)。</p>                    <p>点击连接下载此插件：&nbsp;<a href="http://rrurl.cn/fSBV1M">jQuery-Offline</a>                    </p>                    <p>为了使用这个插件，我们将调用的getJSON方法改为retrieveJSON。&nbsp;我们还要做一个小的改动， 后者将执行两次，一次从缓存中抽数据，再次从服务器获得新的内容。&nbsp;这将导致文章出现两次，如果我们只是简单的网页面上追加文章数据的话。</p>                    &lt;script type=&ldquo;text/javascript&rdquo;&gt;$.retrieveJSON(&lsquo;/posts.json&rsquo;, function(data) {$( &ldquo;#blog_posts&rdquo; ).html($( &ldquo;#post_template&rdquo; ).tmpl( data ));});&lt;/script&gt;                    这样这个blog程序就可以以正确的页面大小离线浏览了！你可以在这里下载这个Demo：<a href="http://rrurl.cn/9hMX7x">离线博客</a>&nbsp;。                    <p>&nbsp;</p>                    <p>英文参考：<br>Mobile development with HTML5</p>                                 

                </div>
                <div class="article_meta">
                    <span>tagged:</span>
                    
                    <a class="tag" href="http://openq.cn/tag/front-end/">front end</a>
                    
                </div>
            </div>
        </div>
        <div class="sep"></div>
    </li>
    
</ul>


<a id="prev" href="/page/6/" class="v_nav" >
    <span class="icon">Prev</span>
</a>



<a id="next" href="/page/8/" class="v_nav" >
    <span class="icon">Next</span>
</a>



</div>
<div id="footer_wrapper">
    <div id="footer">
        <div id="footer_inner">
            <div class="tag_cloud col">
                <h2>Tag Cloud</h2>
                <ul>
                
                <li><a class="tag" href="http://openq.cn/tag/cultivation/">cultivation (8)</a></li>
                
                <li><a class="tag" href="http://openq.cn/tag/Mood/">Mood (4)</a></li>
                
                <li><a class="tag" href="http://openq.cn/tag/design/">design (4)</a></li>
                
                <li><a class="tag" href="http://openq.cn/tag/iOS/">iOS (3)</a></li>
                
                <li><a class="tag" href="http://openq.cn/tag/front-end/">front end (2)</a></li>
                
                <li><a class="tag" href="http://openq.cn/tag/hybrid/">hybrid (2)</a></li>
                
                <li><a class="tag" href="http://openq.cn/tag/svn/">svn (1)</a></li>
                
                <li><a class="tag" href="http://openq.cn/tag/mac-tools/">mac tools (1)</a></li>
                
                <li><a class="tag" href="http://openq.cn/tag/cloud-engine/">cloud engine (1)</a></li>
                
                <li><a class="tag" href="http://openq.cn/tag/http/">http (1)</a></li>
                
                <li><a class="tag" href="http://openq.cn/tag/coding/">coding (1)</a></li>
                
                <li><a class="tag" href="http://openq.cn/tag/perl/">perl (1)</a></li>
                
                <li><a class="tag" href="http://openq.cn/tag/sn/">sn (1)</a></li>
                
                <li><a class="tag" href="http://openq.cn/tag/tools/">tools (1)</a></li>
                
                <li><a class="tag" href="http://openq.cn/tag/share/">share (1)</a></li>
                
                <li><a class="tag" href="http://openq.cn/tag/webkit/">webkit (1)</a></li>
                
                <li><a class="tag" href="http://openq.cn/tag/this-blog/">this blog (1)</a></li>
                
                <li><a class="tag" href="http://openq.cn/tag/best-practices/">best practices (1)</a></li>
                
                <li><a class="tag" href="http://openq.cn/tag/meeting/">meeting (1)</a></li>
                
                <li><a class="tag" href="http://openq.cn/tag/regex/">regex (1)</a></li>
                
                </ul>
            </div>
            <div class="col">
                <h2>Archives</h2>
                <ul>
                    
                    <li><a href="http://openq.cn/archive/2014/">2014 (3)</a></li>
                    
                    <li><a href="http://openq.cn/archive/2012/">2012 (23)</a></li>
                    
                    <li><a href="http://openq.cn/archive/2011/">2011 (3)</a></li>
                    
                    <li><a href="http://openq.cn/archive/2010/">2010 (1)</a></li>
                    
                    <li><a href="http://openq.cn/archive/2009/">2009 (2)</a></li>
                    
                </ul>
            </div>
            <div class="col">
                <h2>Links</h2>
                <ul>
                    
                    <li><a href="http://openq.cn" title="That's Nice!" target="_blank">openQ</a></li>
                    
                </ul>
            </div>
            <div class="copyright">
                Powered by <a href="https://github.com/whtsky/catsup">Catsup</a>
                <span>&bull;</span>
                SealScript Theme by <a href="http://lyric.im">Lyric</a>
                <script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F88ad466865ee70215586d741da736f7f' type='text/javascript'%3E%3C/script%3E"));
</script>
            </div>
        </div>
    </div>
</div>
</body>
</html>

